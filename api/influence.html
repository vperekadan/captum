<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Captum · Model Interpretability for PyTorch</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Model Interpretability for PyTorch"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Captum · Model Interpretability for PyTorch"/><meta property="og:type" content="website"/><meta property="og:url" content="https://captum.ai/"/><meta property="og:description" content="Model Interpretability for PyTorch"/><meta property="og:image" content="https://captum.ai/img/captum-icon.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://captum.ai/img/captum.png"/><link rel="shortcut icon" href="/img/captum.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-44373548-48', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="/js/code_block_buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/captum_logo.svg" alt="Captum"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/introduction" target="_self">Docs</a></li><li class=""><a href="/tutorials/" target="_self">Tutorials</a></li><li class=""><a href="/api/" target="_self">API Reference</a></li><li class=""><a href="https://github.com/pytorch/captum" target="_self">GitHub</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div>
<script type="text/javascript" id="documentation_options" data-url_root="./"
src="/_sphinx/documentation_options.js"></script>
<script type="text/javascript" src="/_sphinx/jquery.js"></script>
<script type="text/javascript" src="/_sphinx/underscore.js"></script>
<script type="text/javascript" src="/_sphinx/doctools.js"></script>
<script type="text/javascript" src="/_sphinx/language_data.js"></script>
<script type="text/javascript" src="/_sphinx/searchtools.js"></script>

<script src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js"></script>
<script src="/_sphinx/katex_autorenderer.js"></script>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css" />
<div class="sphinx wrapper"><div class="document">
<div class="documentwrapper">
<div class="bodywrapper">
<div class="body" role="main">
<section id="influential-examples">
<h1>Influential Examples<a class="headerlink" href="#influential-examples" title="Link to this heading">¶</a></h1>
<section id="datainfluence">
<h2>DataInfluence<a class="headerlink" href="#datainfluence" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="captum.influence.DataInfluence">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">captum.influence.</span></span><span class="sig-name descname"><span class="pre">DataInfluence</span></span><a class="reference internal" href="_modules/captum/influence/_core/influence.html#DataInfluence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#captum.influence.DataInfluence" title="Link to this definition">¶</a></dt>
<dd><p>An abstract class to define model data influence skeleton.</p>
<dl class="py method">
<dt class="sig sig-object py" id="captum.influence.DataInfluence.get_name">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_name</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/captum/influence/_core/influence.html#DataInfluence.get_name"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#captum.influence.DataInfluence.get_name" title="Link to this definition">¶</a></dt>
<dd><p>Create readable class name.  Due to the nature of the names of <cite>TracInCPBase</cite>
subclasses, simply returns the class name.  For example, for a class called
TracInCP, we return the string TracInCP.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a readable class name</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>name (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a>)</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="captum.influence.DataInfluence.influence">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">influence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/captum/influence/_core/influence.html#DataInfluence.influence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#captum.influence.DataInfluence.influence" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.12)"><em>Any</em></a>) – Batch of examples for which influential
instances are computed. They are passed to the forward_func. If
<cite>inputs</cite> if a tensor or tuple of tensors, the first dimension
of a tensor corresponds to the batch dimension.</p></li>
<li><p><strong>**kwargs</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.12)"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a></span>) – Additional key-value arguments that are necessary for specific
implementation of <cite>DataInfluence</cite> abstract class.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>We do not add restrictions on the return type for now,</dt><dd><p>though this may change in the future.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>influences (Any)</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
</section>
<section id="similarityinfluence">
<h2>SimilarityInfluence<a class="headerlink" href="#similarityinfluence" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="captum.influence.SimilarityInfluence">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">captum.influence.</span></span><span class="sig-name descname"><span class="pre">SimilarityInfluence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">influence_src_dataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">activation_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">similarity_metric</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">cosine_similarity</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">similarity_direction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'max'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/captum/influence/_core/similarity_influence.html#SimilarityInfluence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#captum.influence.SimilarityInfluence" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>module</strong> (<a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module" title="(in PyTorch v2.2)"><em>torch.nn.Module</em></a>) – An instance of pytorch model. This model should
define all of its layers as attributes of the model.</p></li>
<li><p><strong>layers</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><em>list</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>]</em>) – The fully qualified layer(s) for which the
activation vectors are computed.</p></li>
<li><p><strong>influence_src_dataset</strong> (<a class="reference external" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.Dataset" title="(in PyTorch v2.2)"><em>torch.utils.data.Dataset</em></a>) – PyTorch Dataset that is
used to create a PyTorch Dataloader to iterate over the dataset and
its labels. This is the dataset for which we will be seeking for
influential instances. In most cases this is the training dataset.</p></li>
<li><p><strong>activation_dir</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a>) – The directory of the path to store
and retrieve activation computations. Best practice would be to use
an absolute path.</p></li>
<li><p><strong>model_id</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a>) – The name/version of the model for which layer
activations are being computed. Activations will be stored and
loaded under the subdirectory with this name if provided.</p></li>
<li><p><strong>similarity_metric</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Callable" title="(in Python v3.12)"><em>Callable</em></a>) – <p>This is a callable function that computes a
similarity metric between two representations. For example, the
representations pair could be from the training and test sets.</p>
<p>This function must adhere to certain standards. The inputs should be
torch Tensors with shape (batch_size_i/j, feature dimensions). The
output Tensor should have shape (batch_size_i, batch_size_j) with
scalar values corresponding to the similarity metric used for each
pairwise combination from the two batches.</p>
<p>For example, suppose we use <cite>batch_size_1 = 16</cite> for iterating
through <cite>influence_src_dataset</cite>, and for the <cite>inputs</cite> argument
we pass in a Tensor with 3 examples, i.e. batch_size_2 = 3. Also,
suppose that our inputs and intermediate activations throughout the
model will have dimension (N, C, H, W). Then, the feature dimensions
should be flattened within this function. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">av_test</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([3, N, C, H, W])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">av_src</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([16, N, C, H, W])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">av_test</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">av_test</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">av_test</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([3, N x C x H x W])</span>
</pre></div>
</div>
<p>and similarly for av_src. The similarity_metric should then use
these flattened tensors to return the pairwise similarity matrix.
For example, <cite>similarity_metric(av_test, av_src)</cite> should return a
tensor of shape (3, 16).</p>
</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a>) – Batch size for iterating through <cite>influence_src_dataset</cite>.</p></li>
<li><p><strong>**kwargs</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.12)"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a></span>) – Additional key-value arguments that are necessary for specific
implementation of <cite>DataInfluence</cite> abstract class.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="captum.influence.SimilarityInfluence.influence">
<span class="sig-name descname"><span class="pre">influence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">top_k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">additional_forward_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">load_src_from_disk</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/captum/influence/_core/similarity_influence.html#SimilarityInfluence.influence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#captum.influence.SimilarityInfluence.influence" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> (<a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.2)"><em>Tensor</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><em>tuple</em></a><em>[</em><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.2)"><em>Tensor</em></a><em>, </em><em>...</em><em>]</em>) – Batch of examples for which
influential instances are computed. They are passed to the
forward_func. The first dimension in <cite>inputs</cite> tensor or tuple
of tensors corresponds to the batch size. A tuple of tensors
is only passed in if thisis the input form that <cite>module</cite> accepts.</p></li>
<li><p><strong>top_k</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a>) – The number of top-matching activations to return</p></li>
<li><p><strong>additional_forward_args</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.12)"><em>Any</em></a><em>, </em><em>optional</em>) – Additional arguments that will be
passed to forward_func after inputs.</p></li>
<li><p><strong>load_src_from_disk</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a>) – Loads activations for <cite>influence_src_dataset</cite>
where possible. Setting to False would force regeneration of
activations.</p></li>
<li><p><strong>load_input_from_disk</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a>) – Regenerates activations for inputs by default
and removes previous <cite>inputs</cite> activations that are flagged with
<cite>inputs_id</cite>. Setting to True will load prior matching inputs
activations. Note that this could lead to unexpected behavior if
<cite>inputs_id</cite> is not configured properly and activations are loaded
for a different, prior <cite>inputs</cite>.</p></li>
<li><p><strong>inputs_id</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a>) – Used to identify inputs for loading activations.</p></li>
<li><p><strong>**kwargs</strong> (<span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.12)"><code class="xref py py-data docutils literal notranslate"><span class="pre">Any</span></code></a></span>) – Additional key-value arguments that are necessary for specific
implementation of <cite>DataInfluence</cite> abstract class.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Returns the influential instances retrieved from</dt><dd><p><cite>influence_src_dataset</cite> for each test example represented through a
tensor or a tuple of tensor in <cite>inputs</cite>. Returned influential
examples are represented as dict, with keys corresponding to
the layer names passed in <cite>layers</cite>. Each value in the dict is a
tuple containing the indices and values for the top k similarities
from <cite>influence_src_dataset</cite> by the chosen metric. The first value
in the tuple corresponds to the indices corresponding to the top k
most similar examples, and the second value is the similarity score.
The batch dimension corresponds to the batch dimension of <cite>inputs</cite>.
If inputs.shape[0] == 5, then dict[<cite>layer_name</cite>][0].shape[0] == 5.
These tensors will be of shape (inputs.shape[0], top_k).</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>influences (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)">dict</a>)</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
</section>
<section id="tracincpbase">
<h2>TracInCPBase<a class="headerlink" href="#tracincpbase" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="captum.influence.TracInCPBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">captum.influence.</span></span><span class="sig-name descname"><span class="pre">TracInCPBase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_dataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checkpoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checkpoints_load_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">_load_flexible_state_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss_fn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_loss_fn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/captum/influence/_core/tracincp.html#TracInCPBase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#captum.influence.TracInCPBase" title="Link to this definition">¶</a></dt>
<dd><p>To implement the <cite>influence</cite> method, classes inheriting from <cite>TracInCPBase</cite> will
separately implement the private <cite>_self_influence</cite>, <cite>_get_k_most_influential</cite>,
and <cite>_influence</cite> methods. The public <cite>influence</cite> method is a wrapper for these
private methods.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module" title="(in PyTorch v2.2)"><em>torch.nn.Module</em></a>) – An instance of pytorch model. This model should
define all of its layers as attributes of the model.</p></li>
<li><p><strong>train_dataset</strong> (<a class="reference external" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.Dataset" title="(in PyTorch v2.2)"><em>torch.utils.data.Dataset</em></a><em> or </em><a class="reference external" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader" title="(in PyTorch v2.2)"><em>torch.utils.data.DataLoader</em></a>) – In the <cite>influence</cite> method, we compute the influence score of
training examples on examples in a test batch.
This argument represents the training dataset containing those
training examples. In order to compute those influence scores, we
will create a Pytorch DataLoader yielding batches of training
examples that is then used for processing. If this argument is
already a Pytorch Dataloader, that DataLoader can be directly
used for processing. If it is instead a Pytorch Dataset, we will
create a DataLoader using it, with batch size specified by
<cite>batch_size</cite>. For efficiency purposes, the batch size of the
DataLoader used for processing should be as large as possible, but
not too large, so that certain intermediate quantities created
from a batch still fit in memory. Therefore, if
<cite>train_dataset</cite> is a Dataset, <cite>batch_size</cite> should be large.
If <cite>train_dataset</cite> was already a DataLoader to begin with,
it should have been constructed to have a large batch size. It is
assumed that the Dataloader (regardless of whether it is created
from a Pytorch Dataset or not) yields tuples. For a <cite>batch</cite> that is
yielded, of length <cite>L</cite>, it is assumed that the forward function of
<cite>model</cite> accepts <cite>L-1</cite> arguments, and the last element of <cite>batch</cite> is
the label. In other words, <cite>model(*batch[:-1])</cite> gives the output of
<cite>model</cite>, and <cite>batch[-1]</cite> are the labels for the batch.</p></li>
<li><p><strong>checkpoints</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><em>list</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>]</em><em>, or </em><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Iterator" title="(in Python v3.12)"><em>Iterator</em></a>) – Either the directory of the
path to store and retrieve model checkpoints, a list of
filepaths with checkpoints from which to load, or an iterator which
returns objects from which to load checkpoints.</p></li>
<li><p><strong>checkpoints_load_func</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Callable" title="(in Python v3.12)"><em>Callable</em></a><em>, </em><em>optional</em>) – The function to load a saved
checkpoint into a model to update its parameters, and get the
learning rate if it is saved. By default uses a utility to load a
model saved as a state dict.
Default: _load_flexible_state_dict</p></li>
<li><p><strong>loss_fn</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Callable" title="(in Python v3.12)"><em>Callable</em></a><em>, </em><em>optional</em>) – The loss function applied to model.
Default: None</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em> or </em><em>None</em><em>, </em><em>optional</em>) – Batch size of the DataLoader created to
iterate through <cite>train_dataset</cite>, if it is a Dataset.
<cite>batch_size</cite> should be chosen as large as possible so that certain
intermediate quantities created from a batch still fit in memory.
Specific implementations of <cite>TracInCPBase</cite> will detail the size of
the intermediate quantities. <cite>batch_size</cite> must be an int if
<cite>train_dataset</cite> is a Dataset. If <cite>train_dataset</cite>
is a DataLoader, then <cite>batch_size</cite> is ignored as an argument.
Default: 1</p></li>
<li><p><strong>test_loss_fn</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Callable" title="(in Python v3.12)"><em>Callable</em></a><em>, </em><em>optional</em>) – In some cases, one may want to use a
separate loss functions for training examples, i.e. those in
<cite>train_dataset</cite>, and for test examples, i.e. those
represented by the <cite>inputs</cite> and <cite>targets</cite> arguments to the
<cite>influence</cite> method. For example, if one wants to calculate the
influence score of a training example on a test example’s
prediction for a fixed class, <cite>test_loss_fn</cite> could map from the
logits for all classes to the logits for a fixed class.
<cite>test_loss_fn</cite> needs to satisfy the same constraints as <cite>loss_fn</cite>.
If not provided, the loss function for test examples is assumed to
be the same as the loss function for training examples, i.e.
<cite>loss_fn</cite>.
Default: None</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="captum.influence.TracInCPBase.get_name">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_name</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/captum/influence/_core/tracincp.html#TracInCPBase.get_name"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#captum.influence.TracInCPBase.get_name" title="Link to this definition">¶</a></dt>
<dd><p>Create readable class name.  Due to the nature of the names of <cite>TracInCPBase</cite>
subclasses, simplies returns the class name.  For example, for a class called
TracInCP, we return the string TracInCP.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a readable class name</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>name (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a>)</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="captum.influence.TracInCPBase.influence">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">influence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proponents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unpack_inputs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_progress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/captum/influence/_core/tracincp.html#TracInCPBase.influence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#captum.influence.TracInCPBase.influence" title="Link to this definition">¶</a></dt>
<dd><p>This is the key method of this class, and can be run in 2 different modes,
where the mode that is run depends on the arguments passed to this method:</p>
<ul class="simple">
<li><p>influence score mode: This mode is used if <cite>k</cite> is None. This mode computes
the influence score of every example in training dataset <cite>train_dataset</cite>
on every example in the test batch represented by <cite>inputs</cite>.</p></li>
<li><p>k-most influential mode: This mode is used if <cite>k</cite> is not None, and an int.
This mode computes the proponents or opponents of every example in the
test batch represented by <cite>inputs</cite>. In particular, for each test example in
the test batch, this mode computes its proponents (resp. opponents),
which are the indices in the training dataset <cite>train_dataset</cite> of the
training examples with the <cite>k</cite> highest (resp. lowest) influence scores on the
test example. Proponents are computed if <cite>proponents</cite> is True. Otherwise,
opponents are computed. For each test example, this method also returns the
actual influence score of each proponent (resp. opponent) on the test
example.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><em>tuple</em></a>) – <cite>inputs</cite> is the test batch and is a tuple of
any, where the last element is assumed to be the labels for the
batch. That is, <cite>model(*batch[0:-1])</cite> produces the output for
<cite>model</cite>, and <cite>batch[-1]</cite> are the labels, if any. This is the same
assumption made for each batch yielded by training dataset
<cite>train_dataset</cite> - please see its documentation in <cite>__init__</cite> for
more details on the assumed structure of a batch.</p></li>
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – If not provided or <cite>None</cite>, the influence score mode will
be run. Otherwise, the k-most influential mode will be run,
and <cite>k</cite> is the number of proponents / opponents to return per
example in the test batch.
Default: None</p></li>
<li><p><strong>proponents</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Whether seeking proponents (<cite>proponents=True</cite>)
or opponents (<cite>proponents=False</cite>), if running in k-most influential
mode.
Default: True</p></li>
<li><p><strong>show_progress</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – For all modes, computation of results
requires “training dataset computations”: computations for each
batch in the training dataset <cite>train_dataset</cite>, which may
take a long time. If <cite>show_progress</cite> is true, the progress of
“training dataset computations” will be displayed. In particular,
the number of batches for which computations have been performed
will be displayed. It will try to use tqdm if available for
advanced features (e.g. time estimation). Otherwise, it will
fallback to a simple output of progress.
Default: False</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Union" title="(in Python v3.12)"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code></a>[<a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.2)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">KMostInfluentialResults</span></code>]</span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><p>The return value of this method depends on which mode is run.</p>
<ul class="simple">
<li><p>influence score mode: if this mode is run (<cite>k</cite> is None), returns a 2D
tensor <cite>influence_scores</cite> of shape <cite>(input_size, train_dataset_size)</cite>,
where <cite>input_size</cite> is the number of examples in the test batch, and
<cite>train_dataset_size</cite> is the number of examples in training dataset
<cite>train_dataset</cite>. In other words, <cite>influence_scores[i][j]</cite> is the
influence score of the <cite>j</cite>-th example in <cite>train_dataset</cite> on the <cite>i</cite>-th
example in the test batch.</p></li>
<li><p>k-most influential mode: if this mode is run (<cite>k</cite> is an int), returns
a namedtuple <cite>(indices, influence_scores)</cite>. <cite>indices</cite> is a 2D tensor of
shape <cite>(input_size, k)</cite>, where <cite>input_size</cite> is the number of examples in
the test batch. If computing proponents (resp. opponents),
<cite>indices[i][j]</cite> is the index in training dataset <cite>train_dataset</cite> of the
example with the <cite>j</cite>-th highest (resp. lowest) influence score (out of
the examples in <cite>train_dataset</cite>) on the <cite>i</cite>-th example in the test
dataset. <cite>influence_scores</cite> contains the corresponding influence scores.
In particular, <cite>influence_scores[i][j]</cite> is the influence score of example
<cite>indices[i][j]</cite> in <cite>train_dataset</cite> on example <cite>i</cite> in the test batch
represented by <cite>inputs</cite>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="captum.influence.TracInCPBase.self_influence">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">self_influence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_progress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/captum/influence/_core/tracincp.html#TracInCPBase.self_influence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#captum.influence.TracInCPBase.self_influence" title="Link to this definition">¶</a></dt>
<dd><p>If <cite>inputs</cite> is not specified calculates the self influence
scores for the training dataset <cite>train_dataset</cite>. Otherwise, computes
self influence scores for the examples in <cite>inputs</cite>,
which is either a single batch or a Pytorch <cite>DataLoader</cite> that yields
batches. Therefore, in this case, the computed self influence scores
are <em>not</em> for the examples in training dataset <cite>train_dataset</cite>.
Note that if <cite>inputs</cite> is a single batch, this
will call <cite>model</cite> on that single batch, and if <cite>inputs</cite> yields
batches, this will call <cite>model</cite> on each batch that is yielded. Therefore,
please ensure that for both cases, the batch(es) that <cite>model</cite> is called
with are not too large, so that there will not be an out-of-memory error.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><em>tuple</em></a><em> or </em><em>DataLoader</em><em>, </em><em>optional</em>) – This specifies the
dataset for which self influence scores will be computed.
Either a single tuple of any, or a <cite>DataLoader</cite>, where each
batch yielded is a tuple of type any. In either case, the tuple
represents a single batch, where the last element is assumed to
be the labels for the batch. That is, <cite>model(*batch[0:-1])</cite>
produces the output for <cite>model</cite>, and <cite>batch[-1]</cite> are the labels,
if any. This is the same assumption made for each batch yielded
by training dataset <cite>train_dataset</cite>. Please see documentation for
the <cite>train_dataset</cite> argument to <cite>TracInCP.__init__</cite> for
more details on the assumed structure of a batch. If not provided
or <cite>None</cite>, self influence scores will be computed for training
dataset <cite>train_dataset</cite>, which yields batches satisfying the
above assumptions.
Default: None.</p></li>
<li><p><strong>show_progress</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Computation of self influence scores can
take a long time if <cite>inputs</cite> represents many examples. If
<cite>show_progress</cite> is true, the progress of this computation will be
displayed. In more detail, this computation will iterate over all
checkpoints (provided as the <cite>checkpoints</cite> initialization argument)
in an outer loop, and iterate over all batches that
<cite>inputs</cite> represents in an inner loop. Therefore, the
total number of (checkpoint, batch) combinations that need to be
iterated over is
(# of checkpoints x # of batches that <cite>inputs</cite> represents).
If <cite>show_progress</cite> is True, the total progress of both the outer
iteration over checkpoints and the inner iteration over batches is
displayed. It will try to use tqdm if available for advanced
features (e.g. time estimation). Otherwise, it will fallback to a
simple output of progress.
Default: False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>This is a 1D tensor containing the self</dt><dd><p>influence scores of all examples in <cite>inputs</cite>, regardless of
whether it represents a single batch or a <cite>DataLoader</cite> that yields
batches.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>self_influence_scores (Tensor)</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
</section>
<section id="tracincp">
<h2>TracInCP<a class="headerlink" href="#tracincp" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="captum.influence.TracInCP">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">captum.influence.</span></span><span class="sig-name descname"><span class="pre">TracInCP</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_dataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checkpoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checkpoints_load_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">_load_flexible_state_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">layers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss_fn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_loss_fn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_wise_grads_per_batch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/captum/influence/_core/tracincp.html#TracInCP"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#captum.influence.TracInCP" title="Link to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module" title="(in PyTorch v2.2)"><em>torch.nn.Module</em></a>) – An instance of pytorch model. This model should
define all of its layers as attributes of the model.</p></li>
<li><p><strong>train_dataset</strong> (<a class="reference external" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.Dataset" title="(in PyTorch v2.2)"><em>torch.utils.data.Dataset</em></a><em> or </em><a class="reference external" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader" title="(in PyTorch v2.2)"><em>torch.utils.data.DataLoader</em></a>) – In the <cite>influence</cite> method, we compute the influence score of
training examples on examples in a test batch.
This argument represents the training dataset containing those
training examples. In order to compute those influence scores, we
will create a Pytorch DataLoader yielding batches of training
examples that is then used for processing. If this argument is
already a Pytorch Dataloader, that DataLoader can be directly
used for processing. If it is instead a Pytorch Dataset, we will
create a DataLoader using it, with batch size specified by
<cite>batch_size</cite>. For efficiency purposes, the batch size of the
DataLoader used for processing should be as large as possible, but
not too large, so that certain intermediate quantities created
from a batch still fit in memory. Therefore, if
<cite>train_dataset</cite> is a Dataset, <cite>batch_size</cite> should be large.
If <cite>train_dataset</cite> was already a DataLoader to begin with,
it should have been constructed to have a large batch size. It is
assumed that the Dataloader (regardless of whether it is created
from a Pytorch Dataset or not) yields tuples. For a <cite>batch</cite> that is
yielded, of length <cite>L</cite>, it is assumed that the forward function of
<cite>model</cite> accepts <cite>L-1</cite> arguments, and the last element of <cite>batch</cite> is
the label. In other words, <cite>model(*batch[:-1])</cite> gives the output of
<cite>model</cite>, and <cite>batch[-1]</cite> are the labels for the batch.</p></li>
<li><p><strong>checkpoints</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><em>list</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>]</em><em>, or </em><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Iterator" title="(in Python v3.12)"><em>Iterator</em></a>) – Either the directory of the
path to store and retrieve model checkpoints, a list of
filepaths with checkpoints from which to load, or an iterator which
returns objects from which to load checkpoints.</p></li>
<li><p><strong>checkpoints_load_func</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Callable" title="(in Python v3.12)"><em>Callable</em></a><em>, </em><em>optional</em>) – The function to load a saved
checkpoint into a model to update its parameters, and get the
learning rate if it is saved. By default uses a utility to load a
model saved as a state dict.
Default: _load_flexible_state_dict</p></li>
<li><p><strong>layers</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><em>list</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>] or </em><em>None</em><em>, </em><em>optional</em>) – A list of layer names for which
gradients should be computed. If <cite>layers</cite> is None, gradients will
be computed for all layers. Otherwise, they will only be computed
for the layers specified in <cite>layers</cite>.
Default: None</p></li>
<li><p><strong>loss_fn</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Callable" title="(in Python v3.12)"><em>Callable</em></a><em>, </em><em>optional</em>) – The loss function applied to model. There
are two options for the return type of <cite>loss_fn</cite>. First, <cite>loss_fn</cite>
can be a “per-example” loss function - returns a 1D Tensor of
losses for each example in a batch. <cite>nn.BCELoss(reduction=”none”)</cite>
would be an “per-example” loss function. Second, <cite>loss_fn</cite> can be
a “reduction” loss function that reduces the per-example losses,
in a batch, and returns a single scalar Tensor. For this option,
the reduction must be the <em>sum</em> or the <em>mean</em> of the per-example
losses. For instance, <cite>nn.BCELoss(reduction=”sum”)</cite> is acceptable.
Note for the first option, the <cite>sample_wise_grads_per_batch</cite>
argument must be False, and for the second option,
<cite>sample_wise_grads_per_batch</cite> must be True.  Also note that for
the second option, if <cite>loss_fn</cite> has no “reduction” attribute,
the implementation assumes that the reduction is the <em>sum</em> of the
per-example losses.  If this is not the case, i.e. the reduction
is the <em>mean</em>, please set the “reduction” attribute of <cite>loss_fn</cite>
to “mean”, i.e. <cite>loss_fn.reduction = “mean”</cite>.
Default: None</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em> or </em><em>None</em><em>, </em><em>optional</em>) – Batch size of the DataLoader created to
iterate through <cite>train_dataset</cite>, if it is a Dataset.
<cite>batch_size</cite> should be chosen as large as possible so that certain
intermediate quantities created from a batch still fit in memory.
Specific implementations of <cite>TracInCPBase</cite> will detail the size of
the intermediate quantities. <cite>batch_size</cite> must be an int if
<cite>train_dataset</cite> is a Dataset. If <cite>train_dataset</cite>
is a DataLoader, then <cite>batch_size</cite> is ignored as an argument.
Default: 1</p></li>
<li><p><strong>test_loss_fn</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Callable" title="(in Python v3.12)"><em>Callable</em></a><em>, </em><em>optional</em>) – In some cases, one may want to use a
separate loss functions for training examples, i.e. those in
<cite>train_dataset</cite>, and for test examples, i.e. those
represented by the <cite>inputs</cite> and <cite>targets</cite> arguments to the
<cite>influence</cite> method. For example, if one wants to calculate the
influence score of a training example on a test example’s
prediction for a fixed class, <cite>test_loss_fn</cite> could map from the
logits for all classes to the logits for a fixed class.
<cite>test_loss_fn</cite> needs satisfy the same constraints as <cite>loss_fn</cite>.
Thus, the same checks that we apply to <cite>loss_fn</cite> are also applied
to <cite>test_loss_fn</cite>, if the latter is provided. Note that the
constraints on both <cite>loss_fn</cite> and <cite>test_loss_fn</cite> both depend on
<cite>sample_wise_grads_per_batch</cite>. This means <cite>loss_fn</cite> and
<cite>test_loss_fn</cite> must either both be “per-example”  loss functions,
or both be “reduction” loss functions. If not provided, the loss
function for test examples is assumed to be the same as the loss
function for training examples, i.e. <cite>loss_fn</cite>.
Default: None</p></li>
<li><p><strong>sample_wise_grads_per_batch</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – PyTorch’s native gradient
computations w.r.t. model parameters aggregates the results for a
batch and does not allow to access sample-wise gradients w.r.t.
model parameters. This forces us to iterate over each sample in
the batch if we want sample-wise gradients which is computationally
inefficient. We offer an implementation of batch-wise gradient
computations w.r.t. to model parameters which is computationally
more efficient. This implementation can be enabled by setting the
<cite>sample_wise_grad_per_batch</cite> argument to <cite>True</cite>, and should be
enabled if and only if the <cite>loss_fn</cite> argument is a “reduction” loss
function. For example, <cite>nn.BCELoss(reduction=”sum”)</cite> would be a
valid <cite>loss_fn</cite> if this implementation is enabled (see
documentation for <cite>loss_fn</cite> for more details). Note that our
current implementation enables batch-wise gradient computations
only for a limited number of PyTorch nn.Modules: Conv2D and Linear.
This list will be expanded in the near future.  Therefore, please
do not enable this implementation if gradients will be computed
for other kinds of layers.
Default: False</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="captum.influence.TracInCP.compute_intermediate_quantities">
<span class="sig-name descname"><span class="pre">compute_intermediate_quantities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aggregate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/captum/influence/_core/tracincp.html#TracInCP.compute_intermediate_quantities"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#captum.influence.TracInCP.compute_intermediate_quantities" title="Link to this definition">¶</a></dt>
<dd><p>Computes “embedding” vectors for all examples in a single batch, or a
<cite>Dataloader</cite> that yields batches. These embedding vectors are constructed so
that the influence score of a training example on a test example is simply the
dot-product of their corresponding vectors. Allowing a <cite>DataLoader</cite>
yielding batches to be passed in (as opposed to a single batch) gives the
potential to improve efficiency, because we load each checkpoint only once in
this method call. Thus if a <cite>DataLoader</cite> yielding batches is passed in, this
reduces the total number of times each checkpoint is loaded for a dataset,
compared to if a single batch is passed in. The reason we do not just increase
the batch size is that for large models, large batches do not fit in memory.</p>
<p>If <cite>aggregate</cite> is True, the <em>sum</em> of the vectors for all examples is returned,
instead of the vectors for each example. This can be useful for computing the
influence of a given training example on the total loss over a validation
dataset, because due to properties of the dot-product, this influence is the
dot-product of the training example’s vector with the sum of the vectors in the
validation dataset. Also, by doing the sum aggregation within this method as
opposed to outside of it (by computing all vectors for the validation dataset,
then taking the sum) allows memory usage to be reduced.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> (<em>Tuple</em><em>, or </em><em>DataLoader</em>) – Either a single tuple of any, or a
<cite>DataLoader</cite>, where each batch yielded is a tuple of any. In
either case, the tuple represents a single batch, where the last
element is assumed to be the labels for the batch. That is,
<cite>model(*batch[0:-1])</cite> produces the output for <cite>model</cite>, and
and <cite>batch[-1]</cite> are the labels, if any. Here, <cite>model</cite> is model
provided in initialization. This is the same assumption made for
each batch yielded by training dataset <cite>train_dataset</cite>.</p></li>
<li><p><strong>aggregate</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a>) – Whether to return the sum of the vectors for all
examples, as opposed to vectors for each example.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A tensor of dimension</dt><dd><p>(N, D * C). Here, N is the total number of examples in
<cite>inputs</cite> if <cite>aggregate</cite> is False, and 1, otherwise (so that
a 2D tensor is always returned). C is the number of checkpoints
passed as the <cite>checkpoints</cite> argument of <cite>TracInCP.__init__</cite>, and
each row represents the vector for an example. Regarding D: Let I
be the dimension of the output of the last fully-connected layer
times the dimension of the input of the last fully-connected layer.
If <cite>self.projection_dim</cite> is specified in initialization,
D = min(I * C, <cite>self.projection_dim</cite> * C). Otherwise, D = I * C.
In summary, if <cite>self.projection_dim</cite> is None, the dimension of each
vector will be determined by the size of the input and output of
the last fully-connected layer of <cite>model</cite>. Otherwise,
<cite>self.projection_dim</cite> must be an int, and random projection will be
performed to ensure that the vector is of dimension no more than
<cite>self.projection_dim</cite> * C. <cite>self.projection_dim</cite> corresponds to
the variable d in the top of page 15 of the TracIn paper:
<a class="reference external" href="https://arxiv.org/pdf/2002.08484.pdf">https://arxiv.org/pdf/2002.08484.pdf</a>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>intermediate_quantities (Tensor)</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="captum.influence.TracInCP.influence">
<span class="sig-name descname"><span class="pre">influence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proponents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_progress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aggregate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/captum/influence/_core/tracincp.html#TracInCP.influence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#captum.influence.TracInCP.influence" title="Link to this definition">¶</a></dt>
<dd><p>This is the key method of this class, and can be run in 2 different modes,
where the mode that is run depends on the arguments passed to this method.
Below, we describe the 2 modes, when <cite>aggregate</cite> is false:</p>
<ul class="simple">
<li><p>influence score mode: This mode is used if <cite>k</cite> is None. This mode computes
the influence score of every example in training dataset <cite>train_dataset</cite>
on every example in the test dataset represented by <cite>inputs</cite>.</p></li>
<li><p>k-most influential mode: This mode is used if <cite>k</cite> is not None, and an int.
This mode computes the proponents or opponents of every example in the
test dataset represented by <cite>inputs</cite>. In particular, for each test example in
the test dataset, this mode computes its proponents (resp. opponents),
which are the indices in the training dataset <cite>train_dataset</cite> of the
training examples with the <cite>k</cite> highest (resp. lowest) influence scores on the
test example. Proponents are computed if <cite>proponents</cite> is True. Otherwise,
opponents are computed. For each test example, this method also returns the
actual influence score of each proponent (resp. opponent) on the test
example.</p></li>
</ul>
<p>When <cite>aggregate</cite> is True, this method computes “aggregate” influence scores,
which for a given training example, is the <em>sum</em> of its influence scores over
all examples in the test dataset. Below, we describe the 2 modes, when
<cite>aggregate</cite> is True:</p>
<ul class="simple">
<li><p>influence score mode: This mode is used if <cite>k</cite> is None. This mode computes
the aggregate influence score of each example in training dataset
<cite>train_dataset</cite> on the test dataset.</p></li>
<li><p>k-most influential mode: This mode is used if <cite>k</cite> is not None, and an int.
This mode computes the “aggregate” proponents (resp. opponents), which are
the indices in the training dataset <cite>train_dataset</cite> of the examples with the
<cite>k</cite> highest (resp. lowest) aggregate influence scores on the test dataset.
Proponents are computed if <cite>proponents</cite> is True. Otherwise, opponents are
computed. This method also returns the actual aggregate influence scores
of each proponent (resp. opponent) on the test dataset.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> (<em>Tuple</em><em>, or </em><em>DataLoader</em>) – Either a single tuple of any, or a
<cite>DataLoader</cite>, where each batch yielded is a tuple of any. In
either case, the tuple represents a single batch, where the last
element is assumed to be the labels for the batch. That is,
<cite>model(*batch[0:-1])</cite> produces the output for <cite>model</cite>, and
and <cite>batch[-1]</cite> are the labels, if any. Here, <cite>model</cite> is model
provided in initialization. This is the same assumption made for
each batch yielded by training dataset <cite>train_dataset</cite>. Please see
documentation for the <cite>train_dataset</cite> argument to
<cite>TracInCPFastRandProj.__init__</cite> for more details on the assumed
structure of a batch.</p></li>
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – If not provided or <cite>None</cite>, the influence score mode will
be run. Otherwise, the k-most influential mode will be run,
and <cite>k</cite> is the number of proponents / opponents to return per
example in the test batch.
Default: None</p></li>
<li><p><strong>proponents</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Whether seeking proponents (<cite>proponents=True</cite>)
or opponents (<cite>proponents=False</cite>), if running in k-most influential
mode.
Default: True</p></li>
<li><p><strong>show_progress</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – For all modes, computation of results
requires “training dataset computations”: computations for each
batch in the training dataset <cite>train_dataset</cite>, which may
take a long time. If <cite>show_progress</cite> is true, the progress of
“training dataset computations” will be displayed. In particular,
the number of batches for which computations have been performed
will be displayed. It will try to use tqdm if available for
advanced features (e.g. time estimation). Otherwise, it will
fallback to a simple output of progress.
Default: False</p></li>
<li><p><strong>aggregate</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – If true, return “aggregate” influence scores or
examples with the highest / lowest aggregate influence scores on
the test dataset, depending on the mode.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Union" title="(in Python v3.12)"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code></a>[<a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.2)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">KMostInfluentialResults</span></code>]</span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><p>The return value of this method depends on which mode is run, and whether
<cite>aggregate</cite> is True of False.</p>
<p>Below are the return values for the 2 modes, when <cite>aggregate</cite> is False:</p>
<ul class="simple">
<li><p>influence score mode: if this mode is run (<cite>k</cite> is None), returns a 2D
tensor <cite>influence_scores</cite> of shape <cite>(input_size, train_dataset_size)</cite>,
where <cite>input_size</cite> is the number of examples in the test dataset, and
<cite>train_dataset_size</cite> is the number of examples in training dataset
<cite>train_dataset</cite>. In other words, <cite>influence_scores[i][j]</cite> is the
influence score of the <cite>j</cite>-th example in <cite>train_dataset</cite> on the <cite>i</cite>-th
example in the test dataset.</p></li>
<li><p>k-most influential mode: if this mode is run (<cite>k</cite> is an int), returns
a namedtuple <cite>(indices, influence_scores)</cite>. <cite>indices</cite> is a 2D tensor of
shape <cite>(input_size, k)</cite>, where <cite>input_size</cite> is the number of examples in
the test dataset. If computing proponents (resp. opponents),
<cite>indices[i][j]</cite> is the index in training dataset <cite>train_dataset</cite> of the
example with the <cite>j</cite>-th highest (resp. lowest) influence score (out of
the examples in <cite>train_dataset</cite>) on the <cite>i</cite>-th example in the test
dataset. <cite>influence_scores</cite> contains the corresponding influence scores.
In particular, <cite>influence_scores[i][j]</cite> is the influence score of example
<cite>indices[i][j]</cite> in <cite>train_dataset</cite> on example <cite>i</cite> in the test dataset
represented by <cite>inputs</cite>.</p></li>
</ul>
<p>Below are the return values for the 2 modes, when <cite>aggregate</cite> is True:</p>
<ul class="simple">
<li><p>influence score mode: if this mode is run (<cite>k</cite> is None), returns a 2D
tensor <cite>influence_scores</cite> of shape <cite>(1, train_dataset_size)</cite>, where
<cite>influence_scores[0][j] is the aggregate influence score of the `j</cite>-th
example in <cite>train_dataset</cite> on the test dataset.</p></li>
<li><p>k-most influential mode: if this mode is run (<cite>k</cite> is an int), returns a
namedtuple <cite>(indices, influence_scores)</cite>. <cite>indices</cite> is a 2D tensor of
shape <cite>(1, k)</cite>. If computing proponents (resp. opponents),
<cite>indices[0][j]</cite> is the index in training dataset <cite>train_dataset</cite> of the
example with the <cite>j</cite>-th highest (resp. lowest) aggregate influence score
on the test dataset. <cite>influence_scores</cite> contains the corresponding
aggregate influence scores. In particular, <cite>influence_scores[0][j]</cite> is
the aggregate influence score of example <cite>indices[0][j]</cite> on the test
dataset.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="captum.influence.TracInCP.self_influence">
<span class="sig-name descname"><span class="pre">self_influence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_progress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outer_loop_by_checkpoints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/captum/influence/_core/tracincp.html#TracInCP.self_influence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#captum.influence.TracInCP.self_influence" title="Link to this definition">¶</a></dt>
<dd><p>Computes self influence scores for the examples in <cite>inputs</cite>, which is
either a single batch or a Pytorch <cite>DataLoader</cite> that yields batches.
If <cite>inputs</cite> is not specified or <cite>None</cite> calculates self influence
score for the training dataset <cite>train_dataset</cite>. Note that if <cite>inputs</cite>
is a single batch, this will call <cite>model</cite> on that single batch, and if
<cite>inputs</cite> yields batches, this will call <cite>model</cite> on each batch that is
yielded. Therefore, please ensure that for both cases, the batch(es) that
<cite>model</cite> is called with are not too large, so that there will not be an
out-of-memory error.
Internally, this computation requires iterating both over the batches in
<cite>inputs</cite>, as well as different model checkpoints. There are two ways
this iteration can be done. If <cite>outer_loop_by_checkpoints</cite> is False, the outer
iteration will be over batches, and the inner iteration will be over
checkpoints. This has the pro that displaying the progress of the computation
is more intuitive, involving displaying the number of batches for which self
influence scores have been computed. If <cite>outer_loop_by_checkpoints</cite> is True,
the outer iteration will be over checkpoints, and the inner iteration will be
over batches. This has the pro that the checkpoints do not need to be loaded
for each batch. For large models, loading checkpoints can be time-intensive.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><em>tuple</em></a><em> or </em><em>DataLoader</em><em>, </em><em>optional</em>) – This specifies the
dataset for which self influence scores will be computed.
Either a single tuple of any, or a <cite>DataLoader</cite>, where each
batch yielded is a tuple of type any. In either case, the tuple
represents a single batch, where the last element is assumed to
be the labels for the batch. That is, <cite>model(*batch[0:-1])</cite>
produces the output for <cite>model</cite>, and <cite>batch[-1]</cite> are the labels,
if any. This is the same assumption made for each batch yielded
by training dataset <cite>train_dataset</cite>. Please see documentation for
the <cite>train_dataset</cite> argument to <cite>TracInCP.__init__</cite> for
more details on the assumed structure of a batch. If not provided
or <cite>None</cite>, self influence scores will be computed for training
dataset <cite>train_dataset</cite>, which yields batches satisfying the
above assumptions.
Default: None.</p></li>
<li><p><strong>show_progress</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Computation of self influence scores can
take a long time if <cite>inputs</cite> represents many examples. If
<cite>show_progress`is true, the progress of this computation will be
displayed. In more detail, if `outer_loop_by_checkpoints</cite> is False,
this computation will iterate over all batches in an outer loop.
Thus if <cite>show_progress</cite> is True, the number of batches for which
self influence scores have been computed will be displayed. If
<cite>outer_loop_by_checkpoints</cite> is True, this computation will iterate
over all checkpoints (provided as the <cite>checkpoints</cite> initialization
argument) in an outer loop, and iterate over all batches that
<cite>inputs</cite> represents in an inner loop. Thus if
<cite>show_progress</cite> is True, the progress of both the outer
iteration and the inner iterations will be displayed. To show
progress, it will try to use tqdm if available for advanced
features (e.g. time estimation). Otherwise, it will fallback to a
simple output of progress.
Default: False</p></li>
<li><p><strong>outer_loop_by_checkpoints</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – If performing an outer
iteration over checkpoints; see method description for more
details.
Default: False</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.2)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="captum.influence.TracInCP.test_reduction_type">
<span class="sig-name descname"><span class="pre">test_reduction_type</span></span><a class="headerlink" href="#captum.influence.TracInCP.test_reduction_type" title="Link to this definition">¶</a></dt>
<dd><p>Either restore model state after done (would have to place functionality
within influence to restore after every influence call)? or make a copy so that
changes to grad_requires aren’t persistent after using TracIn.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>TODO</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
</section>
<section id="tracincpfast">
<h2>TracInCPFast<a class="headerlink" href="#tracincpfast" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="captum.influence.TracInCPFast">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">captum.influence.</span></span><span class="sig-name descname"><span class="pre">TracInCPFast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">final_fc_layer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_dataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checkpoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checkpoints_load_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">_load_flexible_state_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss_fn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_loss_fn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectorize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/captum/influence/_core/tracincp_fast_rand_proj.html#TracInCPFast"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#captum.influence.TracInCPFast" title="Link to this definition">¶</a></dt>
<dd><p>In Appendix F, Page 14 of the TracIn paper, they show that the calculation
of the influence score of between a test example x’ and a training example x,
can be computed much more quickly than naive back-propagation in the special
case when considering only gradients in the last fully-connected layer. This class
computes influence scores for that special case. Note that the computed
influence scores are exactly the same as when naive back-propagation is used -
there is no loss in accuracy.</p>
<p>In more detail regarding the influence score computation: let :math`x`
and :math`nabla_y f(y)` be the input and output-gradient of the last
fully-connected layer, respectively, for a training example. Similarly, let
:math`x’` and :math`nabla_{y’} f(y’)` be the corresponding quantities for
a test example. Then, the influence score of the training example on the test
example is the sum of the contribution from each checkpoint. The contribution from
a given checkpoint is :math`(x^T x’)(nabla_y f(y)^T nabla_{y’} f(y’))`.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module" title="(in PyTorch v2.2)"><em>torch.nn.Module</em></a>) – An instance of pytorch model. This model should
define all of its layers as attributes of the model.</p></li>
<li><p><strong>final_fc_layer</strong> (<a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module" title="(in PyTorch v2.2)"><em>torch.nn.Module</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a>) – The last fully connected layer in
the network for which gradients will be approximated via fast random
projection method. Can be either the layer module itself, or the
fully qualified name of the layer if it is a defined attribute of
the passed <cite>model</cite>.</p></li>
<li><p><strong>train_dataset</strong> (<a class="reference external" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.Dataset" title="(in PyTorch v2.2)"><em>torch.utils.data.Dataset</em></a><em> or </em><a class="reference external" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader" title="(in PyTorch v2.2)"><em>torch.utils.data.DataLoader</em></a>) – In the <cite>influence</cite> method, we compute the influence score of
training examples on examples in a test batch.
This argument represents the training dataset containing those
training examples. In order to compute those influence scores, we
will create a Pytorch DataLoader yielding batches of training
examples that is then used for processing. If this argument is
already a Pytorch Dataloader, that DataLoader can be directly
used for processing. If it is instead a Pytorch Dataset, we will
create a DataLoader using it, with batch size specified by
<cite>batch_size</cite>. For efficiency purposes, the batch size of the
DataLoader used for processing should be as large as possible, but
not too large, so that certain intermediate quantities created
from a batch still fit in memory. Therefore, if
<cite>train_dataset</cite> is a Dataset, <cite>batch_size</cite> should be large.
If <cite>train_dataset</cite> was already a DataLoader to begin with,
it should have been constructed to have a large batch size. It is
assumed that the Dataloader (regardless of whether it is created
from a Pytorch Dataset or not) yields tuples. For a <cite>batch</cite> that is
yielded, of length <cite>L</cite>, it is assumed that the forward function of
<cite>model</cite> accepts <cite>L-1</cite> arguments, and the last element of <cite>batch</cite> is
the label. In other words, <cite>model(*batch[:-1])</cite> gives the output of
<cite>model</cite>, and <cite>batch[-1]</cite> are the labels for the batch.</p></li>
<li><p><strong>checkpoints</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><em>list</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>]</em><em>, or </em><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Iterator" title="(in Python v3.12)"><em>Iterator</em></a>) – Either the directory of the
path to store and retrieve model checkpoints, a list of
filepaths with checkpoints from which to load, or an iterator which
returns objects from which to load checkpoints.</p></li>
<li><p><strong>checkpoints_load_func</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Callable" title="(in Python v3.12)"><em>Callable</em></a><em>, </em><em>optional</em>) – The function to load a saved
checkpoint into a model to update its parameters, and get the
learning rate if it is saved. By default uses a utility to load a
model saved as a state dict.
Default: _load_flexible_state_dict</p></li>
<li><p><strong>loss_fn</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Callable" title="(in Python v3.12)"><em>Callable</em></a><em>, </em><em>optional</em>) – The loss function applied to model. <cite>loss_fn</cite>
must be a “reduction” loss function that reduces the per-example
losses in a batch, and returns a single scalar Tensor. Furthermore,
the reduction must be the <em>sum</em> or the <em>mean</em> of the per-example
losses. For instance, <cite>nn.BCELoss(reduction=”sum”)</cite> is acceptable.
Also note that if <cite>loss_fn</cite> has no “reduction” attribute,
the implementation assumes that the reduction is the <em>sum</em> of the
per-example losses.  If this is not the case, i.e. the reduction
is the <em>mean</em>, please set the “reduction” attribute of <cite>loss_fn</cite>
to “mean”, i.e. <cite>loss_fn.reduction = “mean”</cite>.
Default: None</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em> or </em><em>None</em><em>, </em><em>optional</em>) – Batch size of the DataLoader created to
iterate through <cite>train_dataset</cite>, if it is a Dataset.
<cite>batch_size</cite> should be chosen as large as possible so that certain
intermediate quantities created from a batch still fit in memory.
Specific implementations of <cite>TracInCPBase</cite> will detail the size of
the intermediate quantities. <cite>batch_size</cite> must be an int if
<cite>train_dataset</cite> is a Dataset. If <cite>train_dataset</cite>
is a DataLoader, then <cite>batch_size</cite> is ignored as an argument.
Default: 1</p></li>
<li><p><strong>test_loss_fn</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Callable" title="(in Python v3.12)"><em>Callable</em></a><em>, </em><em>optional</em>) – In some cases, one may want to use a
separate loss functions for training examples, i.e. those in
<cite>train_dataset</cite>, and for test examples, i.e. those
represented by the <cite>inputs</cite> and <cite>targets</cite> arguments to the
<cite>influence</cite> method. For example, if one wants to calculate the
influence score of a training example on a test example’s
prediction for a fixed class, <cite>test_loss_fn</cite> could map from the
logits for all classes to the logits for a fixed class.
<cite>test_loss_fn</cite> needs satisfy the same constraints as <cite>loss_fn</cite>.
Thus, the same checks that we apply to <cite>loss_fn</cite> are also applied
to <cite>test_loss_fn</cite>, if the latter is provided. If not provided, the
loss function for test examples is assumed to be the same as the
loss function for training examples, i.e. <cite>loss_fn</cite>.
Default: None</p></li>
<li><p><strong>vectorize</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Flag to use experimental vectorize functionality
for <cite>torch.autograd.functional.jacobian</cite>.
Default: False</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="captum.influence.TracInCPFast.influence">
<span class="sig-name descname"><span class="pre">influence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proponents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_progress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/captum/influence/_core/tracincp_fast_rand_proj.html#TracInCPFast.influence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#captum.influence.TracInCPFast.influence" title="Link to this definition">¶</a></dt>
<dd><p>This is the key method of this class, and can be run in 2 different modes,
where the mode that is run depends on the arguments passed to this method:</p>
<ul class="simple">
<li><p>influence score mode: This mode is used if <cite>k</cite> is None. This mode computes
the influence score of every example in training dataset <cite>train_dataset</cite>
on every example in the test batch represented by <cite>inputs</cite>.</p></li>
<li><p>k-most influential mode: This mode is used if <cite>k</cite> is not None, and an int.
This mode computes the proponents or opponents of every example in the
test batch represented by <cite>inputs</cite>. In particular, for each test example in
the test batch, this mode computes its proponents (resp. opponents),
which are the indices in the training dataset <cite>train_dataset</cite> of the
training examples with the <cite>k</cite> highest (resp. lowest) influence scores on the
test example. Proponents are computed if <cite>proponents</cite> is True. Otherwise,
opponents are computed. For each test example, this method also returns the
actual influence score of each proponent (resp. opponent) on the test
example.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><em>tuple</em></a><em> or </em><em>DataLoader</em>) – <cite>inputs</cite> is the test batch and is a tuple of
any, where the last element is assumed to be the labels for the
batch. That is, <cite>model(*batch[0:-1])</cite> produces the output for
<cite>model</cite>, and <cite>batch[-1]</cite> are the labels, if any. This is the same
assumption made for each batch yielded by training dataset
<cite>train_dataset</cite> - please see its documentation in <cite>__init__</cite> for
more details on the assumed structure of a batch.</p></li>
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – If not provided or <cite>None</cite>, the influence score mode will
be run. Otherwise, the k-most influential mode will be run,
and <cite>k</cite> is the number of proponents / opponents to return per
example in the test batch.
Default: None</p></li>
<li><p><strong>proponents</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Whether seeking proponents (<cite>proponents=True</cite>)
or opponents (<cite>proponents=False</cite>), if running in k-most influential
mode.
Default: True</p></li>
<li><p><strong>show_progress</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – For all modes, computation of results
requires “training dataset computations”: computations for each
batch in the training dataset <cite>train_dataset</cite>, which may
take a long time. If <cite>show_progress</cite> is true, the progress of
“training dataset computations” will be displayed. In particular,
the number of batches for which computations have been performed
will be displayed. It will try to use tqdm if available for
advanced features (e.g. time estimation). Otherwise, it will
fallback to a simple output of progress.
Default: False</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Union" title="(in Python v3.12)"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code></a>[<a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.2)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">KMostInfluentialResults</span></code>]</span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><p>The return value of this method depends on which mode is run.</p>
<ul class="simple">
<li><p>influence score mode: if this mode is run (<cite>k</cite> is None), returns a 2D
tensor <cite>influence_scores</cite> of shape <cite>(input_size, train_dataset_size)</cite>,
where <cite>input_size</cite> is the number of examples in the test batch, and
<cite>train_dataset_size</cite> is the number of examples in training dataset
<cite>train_dataset</cite>. In other words, <cite>influence_scores[i][j]</cite> is the
influence score of the <cite>j</cite>-th example in <cite>train_dataset</cite> on the <cite>i</cite>-th
example in the test batch.</p></li>
<li><p>k-most influential mode: if this mode is run (<cite>k</cite> is an int), returns
a namedtuple <cite>(indices, influence_scores)</cite>. <cite>indices</cite> is a 2D tensor of
shape <cite>(input_size, k)</cite>, where <cite>input_size</cite> is the number of examples in
the test batch. If computing proponents (resp. opponents),
<cite>indices[i][j]</cite> is the index in training dataset <cite>train_dataset</cite> of the
example with the <cite>j</cite>-th highest (resp. lowest) influence score (out of
the examples in <cite>train_dataset</cite>) on the <cite>i</cite>-th example in the test
batch. <cite>influence_scores</cite> contains the corresponding influence scores.
In particular, <cite>influence_scores[i][j]</cite> is the influence score of example
<cite>indices[i][j]</cite> in <cite>train_dataset</cite> on example <cite>i</cite> in the test batch
represented by <cite>inputs</cite>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="captum.influence.TracInCPFast.self_influence">
<span class="sig-name descname"><span class="pre">self_influence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_progress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outer_loop_by_checkpoints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/captum/influence/_core/tracincp_fast_rand_proj.html#TracInCPFast.self_influence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#captum.influence.TracInCPFast.self_influence" title="Link to this definition">¶</a></dt>
<dd><p>Computes self influence scores for the examples in <cite>inputs</cite>, which is
either a single batch or a Pytorch <cite>DataLoader</cite> that yields batches.
If <cite>inputs</cite> is not specified or <cite>None</cite> calculates self influence
score for the training dataset <cite>train_dataset</cite>. Note that if <cite>inputs</cite>
is a single batch, this will call <cite>model</cite> on that single batch,
and if <cite>inputs</cite> yields batches, this will call <cite>model</cite>
on each batch that is yielded. Therefore, please ensure that for both cases,
the batch(es) that <cite>model</cite> is called with are not too large, so that
there will not be an out-of-memory error.
Internally, this computation requires iterating both over the batches in
<cite>inputs</cite>, as well as different model checkpoints. There are two ways
this iteration can be done. If <cite>outer_loop_by_checkpoints</cite> is False, the outer
iteration will be over batches, and the inner iteration will be over
checkpoints. This has the pro that displaying the progress of the computation
is more intuitive, involving displaying the number of batches for which self
influence scores have been computed. If <cite>outer_loop_by_checkpoints</cite> is True,
the outer iteration will be over checkpoints, and the inner iteration will be
over batches. This has the pro that the checkpoints do not need to be loaded
for each batch. For large models, loading checkpoints can be time-intensive.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><em>tuple</em></a><em> or </em><em>DataLoader</em><em>, </em><em>optional</em>) – This specifies the
dataset for which self influence scores will be computed.
Either a single tuple of any, or a <cite>DataLoader</cite>, where each
batch yielded is a tuple of type any. In either case, the tuple
represents a single batch, where the last element is assumed to
be the labels for the batch. That is, <cite>model(*batch[0:-1])</cite>
produces the output for <cite>model</cite>, and <cite>batch[-1]</cite> are the labels,
if any. This is the same assumption made for each batch yielded
by training dataset <cite>train_dataset</cite>. Please see documentation for
the <cite>train_dataset</cite> argument to <cite>TracInCP.__init__</cite> for
more details on the assumed structure of a batch. If not provided
or <cite>None</cite>, self influence scores will be computed for training
dataset <cite>train_dataset</cite>, which yields batches satisfying the
above assumptions.
Default: None.</p></li>
<li><p><strong>show_progress</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Computation of self influence scores can
take a long time if <cite>inputs</cite> represents many examples. If
<cite>show_progress`is true, the progress of this computation will be
displayed. In more detail, if `outer_loop_by_checkpoints</cite> is False,
this computation will iterate over all batches in an outer loop.
Thus if <cite>show_progress</cite> is True, the number of batches for which
self influence scores have been computed will be displayed. If
<cite>outer_loop_by_checkpoints</cite> is True, this computation will iterate
over all checkpoints (provided as the <cite>checkpoints</cite> initialization
argument) in an outer loop, and iterate over all batches that
<cite>inputs</cite> represents in an inner loop. Thus if
<cite>show_progress</cite> is True, the progress of both the outer
iteration and the inner iterations will be displayed. To show
progress, it will try to use tqdm if available for advanced
features (e.g. time estimation). Otherwise, it will fallback to a
simple output of progress.
Default: False</p></li>
<li><p><strong>outer_loop_by_checkpoints</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – If performing an outer
iteration over checkpoints; see method description for more
details.
Default: False</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.2)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></a></span></p>
</dd>
</dl>
</dd></dl>
</dd></dl>
</section>
<section id="tracincpfastrandproj">
<h2>TracInCPFastRandProj<a class="headerlink" href="#tracincpfastrandproj" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="captum.influence.TracInCPFastRandProj">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">captum.influence.</span></span><span class="sig-name descname"><span class="pre">TracInCPFastRandProj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">final_fc_layer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_dataset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checkpoints</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">checkpoints_load_func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">_load_flexible_state_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss_fn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">batch_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_loss_fn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectorize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nearest_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projection_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/captum/influence/_core/tracincp_fast_rand_proj.html#TracInCPFastRandProj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#captum.influence.TracInCPFastRandProj" title="Link to this definition">¶</a></dt>
<dd><p>A version of TracInCPFast which is optimized for “interactive” calls to
<cite>influence</cite> for the purpose of calculating proponents / opponents, or
influence scores. “Interactive” means there will be multiple calls to
<cite>influence</cite>, with each call for a different batch of test examples, and
subsequent calls rely on the results of previous calls. The implementation in
this class has been optimized so that each call to <cite>influence</cite> is fast, so that
it can be used for interactive analysis. This class should only be used for
interactive use cases. It should not be used if <cite>influence</cite> will only be
called once, because to enable fast calls to <cite>influence</cite>, time and memory
intensive preprocessing is required in <cite>__init__</cite>. Furthermore, it should not
be used to calculate self influence scores - <cite>TracInCPFast</cite> should be used
instead for that purpose. To enable interactive analysis, this implementation
computes and saves “embedding” vectors for all training examples in
<cite>train_dataset</cite>. Crucially, the influence score of a training
example on a test example is simply the dot-product of their corresponding
vectors, and proponents / opponents can be found by first storing vectors for
training examples in a nearest-neighbor data structure, and then finding the
nearest-neighbors for a test example in terms of dot-product (see appendix F
of the TracIn paper). This class should only be used if calls to <cite>influence</cite>
to obtain proponents / opponents or influence scores will be made in an
“interactive” manner, and there is sufficient memory to store vectors for the
entire <cite>train_dataset</cite>. This is because in order to enable interactive
analysis, this implementation incures overhead in <cite>__init__</cite> to setup the
nearest-neighbors data structure, which is both time and memory intensive, as
vectors corresponding to all training examples needed to be stored. To reduce
memory usage, this implementation enables random projections of those vectors.
Note that the influence scores computed with random projections are less
accurate, though correct in expectation.</p>
<p>In more detail regarding the “embedding” vectors - the influence of a training
example on a test example, when only considering gradients in the last
fully-connected layer, the sum of the contribution from each checkpoint. The
contribution from a given checkpoint is
:math`(x^T x’)(nabla_y f(y)^T nabla_{y’} f(y’))`, using the notation in the
description of <cite>TracInCPFast</cite>. As is, this is not a dot-product of 2 vectors.
However, we can rewrite that contribution as
:math`(x nabla_y f(y)^T) dot (x’ f(y’)^T)`. Both terms in this
product are 2D matrices, as they are outer products, and the “product” is actually
a dot-product, treating both matrices as vectors. Therefore, for a given
checkpoint, its contribution to the “embedding” of an example is just the
outer-product :math`(x nabla_y f(y)^T)`, flattened. Furthemore, to reduce the
dimension of this contribution, we can right-multiply and
left-multiply the outer-product with two separate projection matrices. These
transform :math`nabla_y f(y)` and :math`x` to lower dimensional vectors. While
the dimension of these two lower dimensional vectors do not necessarily need to
be the same, in our implementation, we let them be the same, both equal to the
square root of the desired projection dimension. Finally, the embedding of an
example is the concatenation of the contributions from each checkpoint.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> (<a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module" title="(in PyTorch v2.2)"><em>torch.nn.Module</em></a>) – An instance of pytorch model. This model should
define all of its layers as attributes of the model.</p></li>
<li><p><strong>final_fc_layer</strong> (<a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module" title="(in PyTorch v2.2)"><em>torch.nn.Module</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a>) – The last fully connected layer in
the network for which gradients will be approximated via fast random
projection method. Can be either the layer module itself, or the
fully qualified name of the layer if it is a defined attribute of
the passed <cite>model</cite>.</p></li>
<li><p><strong>train_dataset</strong> (<a class="reference external" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.Dataset" title="(in PyTorch v2.2)"><em>torch.utils.data.Dataset</em></a><em> or </em><a class="reference external" href="https://pytorch.org/docs/stable/data.html#torch.utils.data.DataLoader" title="(in PyTorch v2.2)"><em>torch.utils.data.DataLoader</em></a>) – In the <cite>influence</cite> method, we compute the influence score of
training examples on examples in a test batch.
This argument represents the training dataset containing those
training examples. In order to compute those influence scores, we
will create a Pytorch DataLoader yielding batches of training
examples that is then used for processing. If this argument is
already a Pytorch Dataloader, that DataLoader can be directly
used for processing. If it is instead a Pytorch Dataset, we will
create a DataLoader using it, with batch size specified by
<cite>batch_size</cite>. For efficiency purposes, the batch size of the
DataLoader used for processing should be as large as possible, but
not too large, so that certain intermediate quantities created
from a batch still fit in memory. Therefore, if
<cite>train_dataset</cite> is a Dataset, <cite>batch_size</cite> should be large.
If <cite>train_dataset</cite> was already a DataLoader to begin with,
it should have been constructed to have a large batch size. It is
assumed that the Dataloader (regardless of whether it is created
from a Pytorch Dataset or not) yields tuples. For a <cite>batch</cite> that is
yielded, of length <cite>L</cite>, it is assumed that the forward function of
<cite>model</cite> accepts <cite>L-1</cite> arguments, and the last element of <cite>batch</cite> is
the label. In other words, <cite>model(*batch[:-1])</cite> gives the output of
<cite>model</cite>, and <cite>batch[-1]</cite> are the labels for the batch.</p></li>
<li><p><strong>checkpoints</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><em>list</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><em>str</em></a><em>]</em><em>, or </em><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Iterator" title="(in Python v3.12)"><em>Iterator</em></a>) – Either the directory of the
path to store and retrieve model checkpoints, a list of
filepaths with checkpoints from which to load, or an iterator which
returns objects from which to load checkpoints.</p></li>
<li><p><strong>checkpoints_load_func</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Callable" title="(in Python v3.12)"><em>Callable</em></a><em>, </em><em>optional</em>) – The function to load a saved
checkpoint into a model to update its parameters, and get the
learning rate if it is saved. By default uses a utility to load a
model saved as a state dict.
Default: _load_flexible_state_dict</p></li>
<li><p><strong>loss_fn</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Callable" title="(in Python v3.12)"><em>Callable</em></a><em>, </em><em>optional</em>) – The loss function applied to model. <cite>loss_fn</cite>
must be a “reduction” loss function that reduces the per-example
losses in a batch, and returns a single scalar Tensor. Furthermore,
the reduction must be the <em>sum</em> of the per-example losses. For
instance, <cite>nn.BCELoss(reduction=”sum”)</cite> is acceptable, but
<cite>nn.BCELoss(reduction=”mean”)</cite> is <em>not</em> acceptable.
Default: None</p></li>
<li><p><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em> or </em><em>None</em><em>, </em><em>optional</em>) – Batch size of the DataLoader created to
iterate through <cite>train_dataset</cite>, if it is a Dataset.
<cite>batch_size</cite> should be chosen as large as possible so that certain
intermediate quantities created from a batch still fit in memory.
Specific implementations of <cite>TracInCPBase</cite> will detail the size of
the intermediate quantities. <cite>batch_size</cite> must be an int if
<cite>train_dataset</cite> is a Dataset. If <cite>train_dataset</cite>
is a DataLoader, then <cite>batch_size</cite> is ignored as an argument.
Default: 1</p></li>
<li><p><strong>test_loss_fn</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Callable" title="(in Python v3.12)"><em>Callable</em></a><em>, </em><em>optional</em>) – In some cases, one may want to use a
separate loss functions for training examples, i.e. those in
<cite>train_dataset</cite>, and for test examples, i.e. those
represented by the <cite>inputs</cite> and <cite>targets</cite> arguments to the
<cite>influence</cite> method. For example, if one wants to calculate the
influence score of a training example on a test example’s
prediction for a fixed class, <cite>test_loss_fn</cite> could map from the
logits for all classes to the logits for a fixed class.
<cite>test_loss_fn</cite> needs satisfy the same constraints as <cite>loss_fn</cite>.
Thus, the same checks that we apply to <cite>loss_fn</cite> are also applied
to <cite>test_loss_fn</cite>, if the latter is provided. If not provided, the
loss function for test examples is assumed to be the same as the
loss function for training examples, i.e. <cite>loss_fn</cite>.</p></li>
<li><p><strong>vectorize</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a>) – Flag to use experimental vectorize functionality
for <cite>torch.autograd.functional.jacobian</cite>.
Default: False</p></li>
<li><p><strong>nearest_neighbors</strong> (<em>NearestNeighbors</em><em>, </em><em>optional</em>) – The NearestNeighbors
instance for finding nearest neighbors. If None, defaults to
<cite>AnnoyNearestNeighbors(n_trees=10)</cite>.
Default: None</p></li>
<li><p><strong>projection_dim</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Each example will be represented in
the nearest neighbors data structure with a vector. This vector
is the concatenation of several “checkpoint vectors”, each of which
is computed using a different checkpoint in the <cite>checkpoints</cite>
argument. If <cite>projection_dim</cite> is an int, it represents the
dimension we will project each “checkpoint vector” to, so that the
vector for each example will be of dimension at most
<cite>projection_dim</cite> * C, where C is the number of checkpoints.
Regarding the dimension of each vector, D: Let I be the dimension
of the output of the last fully-connected layer times the dimension
of the input of the last fully-connected layer. If <cite>projection_dim</cite>
is not <cite>None</cite>, then D = min(I * C, <cite>projection_dim</cite> * C).
Otherwise, D = I * C. In summary, if <cite>projection_dim</cite> is None, the
dimension of this vector will be determined by the size of the
input and output of the last fully-connected layer of <cite>model</cite>, and
the number of checkpoints. Otherwise, <cite>projection_dim</cite> must be an
int, and random projection will be performed to ensure that the
vector is of dimension no more than <cite>projection_dim</cite> * C.
<cite>projection_dim</cite> corresponds to the variable d in the top of page
15 of the TracIn paper: <a class="reference external" href="https://arxiv.org/abs/2002.08484">https://arxiv.org/abs/2002.08484</a>.
Default: None</p></li>
<li><p><strong>seed</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – Because this implementation chooses a random
projection, its output is random. Setting this seed specifies the
random seed when choosing the random projection.
Default: 0</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="captum.influence.TracInCPFastRandProj.compute_intermediate_quantities">
<span class="sig-name descname"><span class="pre">compute_intermediate_quantities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/captum/influence/_core/tracincp_fast_rand_proj.html#TracInCPFastRandProj.compute_intermediate_quantities"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#captum.influence.TracInCPFastRandProj.compute_intermediate_quantities" title="Link to this definition">¶</a></dt>
<dd><p>Computes “embedding” vectors for all examples in a single batch, or a
<cite>Dataloader</cite> that yields batches. These embedding vectors are constructed so
that the influence score of a training example on a test example is simply the
dot-product of their corresponding vectors. Please see the documentation for
<cite>TracInCPFastRandProj.__init__</cite> for more details. Allowing a <cite>DataLoader</cite>
yielding batches to be passed in (as opposed to a single batch) gives the
potential to improve efficiency, because we load each checkpoint only once in
this method call. Thus if a <cite>DataLoader</cite> yielding batches is passed in, this
reduces the total number of times each checkpoint is loaded for a dataset,
compared to if a single batch is passed in. The reason we do not just increase
the batch size is that for large models, large batches do not fit in memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>inputs</strong> (<em>Tuple</em><em>, or </em><em>DataLoader</em>) – Either a single tuple of any, or a
<cite>DataLoader</cite>, where each batch yielded is a tuple of any. In
either case, the tuple represents a single batch, where the last
element is assumed to be the labels for the batch. That is,
<cite>model(*batch[0:-1])</cite> produces the output for <cite>model</cite>, and
and <cite>batch[-1]</cite> are the labels, if any. Here, <cite>model</cite> is model
provided in initialization. This is the same assumption made for
each batch yielded by training dataset <cite>train_dataset</cite>. Please see
documentation for the <cite>train_dataset</cite> argument to
<cite>TracInCPFastRandProj.__init__</cite> for more details on the assumed
structure of a batch.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>A tensor of dimension</dt><dd><p>(N, D * C), where N is total number of examples in
<cite>inputs</cite>, C is the number of checkpoints passed as the
<cite>checkpoints</cite> argument of <cite>TracInCPFastRandProj.__init__</cite>, and each
row represents the vector for an example. Regarding D: Let I be the
dimension of the output of the last fully-connected layer times the
dimension of the input of the last fully-connected layer. If
<cite>self.projection_dim</cite> is specified in initialization,
D = min(I * C, <cite>self.projection_dim</cite> * C). Otherwise, D = I * C.
In summary, if <cite>self.projection_dim</cite> is None, the dimension of each
vector will be determined by the size of the input and output of
the last fully-connected layer of <cite>model</cite>. Otherwise,
<cite>self.projection_dim</cite> must be an int, and random projection will be
performed to ensure that the vector is of dimension no more than
<cite>self.projection_dim</cite> * C. <cite>self.projection_dim</cite> corresponds to
the variable d in the top of page 15 of the TracIn paper:
<a class="reference external" href="https://arxiv.org/pdf/2002.08484.pdf">https://arxiv.org/pdf/2002.08484.pdf</a>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>intermediate_quantities (Tensor)</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="captum.influence.TracInCPFastRandProj.influence">
<span class="sig-name descname"><span class="pre">influence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proponents</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/captum/influence/_core/tracincp_fast_rand_proj.html#TracInCPFastRandProj.influence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#captum.influence.TracInCPFastRandProj.influence" title="Link to this definition">¶</a></dt>
<dd><p>This is the key method of this class, and can be run in 2 different modes,
where the mode that is run depends on the arguments passed to this method:</p>
<ul class="simple">
<li><p>influence score mode: This mode is used if <cite>k</cite> is None. This mode computes
the influence score of every example in training dataset <cite>train_dataset</cite>
on every example in the test batch represented by <cite>inputs</cite>.</p></li>
<li><p>k-most influential mode: This mode is used if <cite>k</cite> is not None, and an int.
This mode computes the proponents or opponents of every example in the
test batch represented by <cite>inputs</cite>. In particular, for each test example in
the test batch, this mode computes its proponents (resp. opponents),
which are the indices in the training dataset <cite>train_dataset</cite> of the
training examples with the <cite>k</cite> highest (resp. lowest) influence scores on the
test example. Proponents are computed if <cite>proponents</cite> is True. Otherwise,
opponents are computed. For each test example, this method also returns the
actual influence score of each proponent (resp. opponent) on the test
example.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><em>tuple</em></a>) – <cite>inputs</cite> is the test batch and is a tuple of
any, where the last element is assumed to be the labels for the
batch. That is, <cite>model(*batch[0:-1])</cite> produces the output for
<cite>model</cite>, and <cite>batch[-1]</cite> are the labels, if any. This is the same
assumption made for each batch yielded by training dataset
<cite>train_dataset</cite> - please see its documentation in <cite>__init__</cite> for
more details on the assumed structure of a batch.</p></li>
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><em>int</em></a><em>, </em><em>optional</em>) – If not provided or <cite>None</cite>, the influence score mode will
be run. Otherwise, the k-most influential mode will be run,
and <cite>k</cite> is the number of proponents / opponents to return per
example in the test batch.
Default: None</p></li>
<li><p><strong>proponents</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Whether seeking proponents (<cite>proponents=True</cite>)
or opponents (<cite>proponents=False</cite>), if running in k-most influential
mode.
Default: True</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="sphinx_autodoc_typehints-type"><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Union" title="(in Python v3.12)"><code class="xref py py-data docutils literal notranslate"><span class="pre">Union</span></code></a>[<a class="reference external" href="https://pytorch.org/docs/stable/tensors.html#torch.Tensor" title="(in PyTorch v2.2)"><code class="xref py py-class docutils literal notranslate"><span class="pre">Tensor</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">KMostInfluentialResults</span></code>]</span></p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><p>The return value of this method depends on which mode is run.</p>
<ul class="simple">
<li><p>influence score mode: if this mode is run (<cite>k</cite> is None), returns a 2D
tensor <cite>influence_scores</cite> of shape <cite>(input_size, train_dataset_size)</cite>,
where <cite>input_size</cite> is the number of examples in the test batch, and
<cite>train_dataset_size</cite> is the number of examples in training dataset
<cite>train_dataset</cite>. In other words, <cite>influence_scores[i][j]</cite> is the
influence score of the <cite>j</cite>-th example in <cite>train_dataset</cite> on the <cite>i</cite>-th
example in the test batch.</p></li>
<li><p>k-most influential mode: if this mode is run (<cite>k</cite> is an int), returns
a namedtuple <cite>(indices, influence_scores)</cite>. <cite>indices</cite> is a 2D tensor of
shape <cite>(input_size, k)</cite>, where <cite>input_size</cite> is the number of examples in
the test batch. If computing proponents (resp. opponents),
<cite>indices[i][j]</cite> is the index in training dataset <cite>train_dataset</cite> of the
example with the <cite>j</cite>-th highest (resp. lowest) influence score (out of
the examples in <cite>train_dataset</cite>) on the <cite>i</cite>-th example in the test
batch. <cite>influence_scores</cite> contains the corresponding influence scores.
In particular, <cite>influence_scores[i][j]</cite> is the influence score of example
<cite>indices[i][j]</cite> in <cite>train_dataset</cite> on example <cite>i</cite> in the test batch
represented by <cite>inputs</cite>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="captum.influence.TracInCPFastRandProj.self_influence">
<span class="sig-name descname"><span class="pre">self_influence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inputs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_progress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outer_loop_by_checkpoints</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/captum/influence/_core/tracincp_fast_rand_proj.html#TracInCPFastRandProj.self_influence"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#captum.influence.TracInCPFastRandProj.self_influence" title="Link to this definition">¶</a></dt>
<dd><p>NOT IMPLEMENTED - no need to implement <cite>TracInCPFastRandProj.self_influence</cite>,
as <cite>TracInCPFast.self_influence</cite> is sufficient - the latter does not benefit
from random projections, since no quantities associated with a training
example are stored (other than its self influence score)</p>
<p>Computes self influence scores for a single batch or a Pytorch <cite>DataLoader</cite>
that yields batches. Note that if <cite>inputs</cite> is a single batch, this
will call <cite>model</cite> on that single batch, and if <cite>inputs</cite> yields
batches, this will call <cite>model</cite> on each batch that is yielded. Therefore,
please ensure that for both cases, the batch(es) that <cite>model</cite> is called
with are not too large, so that there will not be an out-of-memory error.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inputs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)"><em>tuple</em></a><em> or </em><em>DataLoader</em>) – Either a single tuple of any, or a
<cite>DataLoader</cite>, where each batch yielded is a tuple of any. In
either case, the tuple represents a single batch, where the last
element is assumed to be the labels for the batch. That is,
<cite>model(*batch[0:-1])</cite> produces the output for <cite>model</cite>,
and <cite>batch[-1]</cite> are the labels, if any. This is the same
assumption made for each batch yielded by training dataset
<cite>train_dataset</cite>. Please see documentation for the
<cite>train_dataset</cite> argument to <cite>TracInCP.__init__</cite> for
more details on the assumed structure of a batch.</p></li>
<li><p><strong>show_progress</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – Computation of self influence scores can
take a long time if <cite>inputs</cite> represents many examples. If
<cite>show_progress</cite> is true, the progress of this computation will be
displayed. In more detail, this computation will iterate over all
checkpoints (provided as the <cite>checkpoints</cite> initialization argument)
and all batches that <cite>inputs</cite> represents. Therefore, the
total number of (checkpoint, batch) combinations that need to be
iterated over is
(# of checkpoints x # of batches that <cite>inputs</cite> represents).
If <cite>show_progress</cite> is True, the total number of such combinations
that have been iterated over is displayed. It will try to use tqdm
if available for advanced features (e.g. time estimation).
Otherwise, it will fallback to a simple output of progress.
Default: False</p></li>
<li><p><strong>outer_loop_by_checkpoints</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)"><em>bool</em></a><em>, </em><em>optional</em>) – If performing an outer
iteration over checkpoints; see method description for more
details.
Default: False</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>This is a 1D tensor containing the self</dt><dd><p>influence scores of all examples in <cite>inputs</cite>, regardless of
whether it represents a single batch or a <cite>DataLoader</cite> that yields
batches.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>self_influence_scores (Tensor)</p>
</dd>
</dl>
</dd></dl>
</dd></dl>
</section>
</section>
</div>
</div>
</div>
<div aria-label="main navigation" class="sphinxsidebar" role="navigation">
<div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Captum</a></h1>
<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="attribution.html">Attribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="llm_attr.html">LLM Attribution Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise_tunnel.html">NoiseTunnel</a></li>
<li class="toctree-l1"><a class="reference internal" href="layer.html">Layer Attribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="neuron.html">Neuron Attribution</a></li>
<li class="toctree-l1"><a class="reference internal" href="metrics.html">Metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="robust.html">Robustness</a></li>
<li class="toctree-l1"><a class="reference internal" href="concept.html">Concept-based Interpretability</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Influential Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#datainfluence">DataInfluence</a></li>
<li class="toctree-l2"><a class="reference internal" href="#similarityinfluence">SimilarityInfluence</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tracincpbase">TracInCPBase</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tracincp">TracInCP</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tracincpfast">TracInCPFast</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tracincpfastrandproj">TracInCPFastRandProj</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="module.html">Module</a></li>
<li class="toctree-l1"><a class="reference internal" href="utilities.html">Utilities</a></li>
<li class="toctree-l1"><a class="reference internal" href="base_classes.html">Base Classes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Insights API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="insights.html">Insights</a></li>
<li class="toctree-l1"><a class="reference internal" href="insights.html#features">Features</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
<li><a href="index.html">Documentation overview</a><ul>
<li>Previous: <a href="concept.html" title="previous chapter">Concept-based Interpretability</a></li>
<li>Next: <a href="module.html" title="next chapter">Module</a></li>
</ul></li>
</ul>
</div>
<div id="searchbox" role="search" style="display: none">
<h3 id="searchlabel">Quick search</h3>
<div class="searchformwrapper">
<form action="search.html" class="search" method="get">
<input aria-labelledby="searchlabel" autocapitalize="off" autocomplete="off" autocorrect="off" name="q" spellcheck="false" type="text"/>
<input type="submit" value="Go"/>
</form>
</div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
</div>
</div>
<div class="clearer"></div>
</div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><div class="footerSection"><h5>Docs</h5><a href="/docs/introduction">Introduction</a><a href="/docs/getting_started">Getting Started</a><a href="/tutorials/">Tutorials</a><a href="/api/">API Reference</a></div><div class="footerSection"><h5>Legal</h5><a href="https://opensource.facebook.com/legal/privacy/" target="_blank" rel="noreferrer noopener">Privacy</a><a href="https://opensource.facebook.com/legal/terms/" target="_blank" rel="noreferrer noopener">Terms</a></div><div class="footerSection"><h5>Social</h5><div class="social"><a class="github-button" href="https://github.com/pytorch/captum" data-count-href="https://github.com/pytorch/captum/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star Captum on GitHub">captum</a></div></div></section><a href="https://opensource.facebook.com/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright"> Copyright © 2024 Facebook Inc.</section><script>
            (function() {
              var BAD_BASE = '/captum/';
              if (window.location.origin !== 'https://captum.ai') {
                var pathname = window.location.pathname;
                var newPathname = pathname.slice(pathname.indexOf(BAD_BASE) === 0 ? BAD_BASE.length : 1);
                var newLocation = 'https://captum.ai/' + newPathname;
                console.log('redirecting to ' + newLocation);
                window.location.href = newLocation;
              }
            })();
          </script></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '207c27d819f967749142d8611de7cb19',
                indexName: 'captum',
                inputSelector: '#search_input_react'
              });
            </script></body></html>